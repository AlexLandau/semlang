// TODO: This is motivational for now, but at some point I'll move the actual implementation to be sem2
@Test(["0"], "0")
@Test(["1"], "1")
@Test(["9"], "9")
@Test(["10"], "10")
@Test(["42"], "42")
@Test(["12345"], "12345")
function Natural.toString(value: Natural): String {
  let sequence = Sequence(Natural.toString.State(value, []<CodePoint>), (state: Natural.toString.State) -> {
    let remainder = state.n.modulo(Natural."10").assume()
    let divided = Natural.dividedBy(state.n, Natural."10").assume()
    let codePoint = CodePoint(remainder + unicodeZero().natural).assume()
    let newCodePoints = state.codePoints.appendFront(codePoint)
    Natural.toString.State(divided, newCodePoints)
  })
  let finishedState = sequence.first((state: Natural.toString.State) -> {
    state.n == Natural."0"
  })
  if (finishedState.codePoints.isEmpty()) {
    String."0"
  } else {
    String(finishedState.codePoints)
  }
}

struct Natural.toString.State {
  n: Natural
  codePoints: List<CodePoint>
}

function unicodeZero(): CodePoint {
  CodePoint."48"
}

function Natural.modulo(left: Natural, right: Natural): Maybe<Natural> {
  let moduloResult: Maybe<Integer> = left.integer.modulo(right)
  Maybe.flatMap(moduloResult, Natural|(_))
}

function Natural.dividedBy(left: Natural, right: Natural): Maybe<Natural> {
  let divisionResult: Maybe<Integer> = left.integer.dividedBy(right)
  Maybe.flatMap(divisionResult, Natural|(_))
}

function Natural.plus(left: Natural, right: Natural): Natural {
  Natural(left.integer + right.integer).assume()
}

function Natural.equals(left: Natural, right: Natural): Boolean {
  Integer.equals(left, right)
}

function List.isEmpty<T>(list: List<T>): Boolean {
  list.size() == Natural."0"
}
