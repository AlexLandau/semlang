@Test(["true", "true"], "3")
@Test(["false", "true"], "2")
@Test(["false", "false"], "5")
function conditionalEarlyReturn(b1: Boolean, b2: Boolean): Integer {
  let v = Var(Boolean."true")
  v.= b2
  let n = if (b1) {
    3
  } else {
    let s = if (v[]) {
      return 2
    } else {
      String."bars"
    }
    s.codePoints.size()
  }

  n + 1
}

/*
So what is this supposed to look like?
We don't want to bother with the return 2 stuff unless b1 is false

let s: Returnable<Integer, String> = if (b1) {
  Returnable.Continue("foo")
} else {
  if (b2) {
    Returnable.Return(2)
  } else {
    Returnable.Continue("bars")
  }
}
Returnable.continue(s, { ... })

That seems pretty obvious, but it's out of line with how other expressions like arguments deal with this in cases where
everything's going to be evaluated unconditionally -- but it's probably important to avoid invoking the condition unnecessarily!
Especially as it may depend on something earlier in the expression.

if (b1) {
  "foo"
} else {
  let b2 = computeSomethingReferential(r)
  if (b2) {
    return 2
  } else {
    "bars"
  }
}

So we sort of need to know if we're in the return target we're looking for and handle differently. If we aren't in the
return target, instead of adding the preassignments, we pass along the preassignments. Except that the interesting bit
here about the if/then/else expressions specifically is that we actually do want to invoke them in-place, sort of.

if (b1) {
  3
} else {
  let b2 = computeSomethingReferential(r)
  let s = if (b2) {
    return 2
  } else {
    "bars"
  }
  s.length()
}

That would turn into something like:
let tmp1: Returnable<Integer, Integer> = if (b1) {
  Returnable.Continue(3)
} else {
  let b2 = computeSomethingReferential(r)
  let sTmp: Returnable<Integer, String> = if (b2) {
    Returnable.Return(2)
  } else {
    Returnable.Continue("bars")
  }
  // Turn a Returnable<Integer, String> into a Returnable<Integer, Integer> given (String) -> Integer
  Returnable.map(sTmp, { s ->
    s.length()
  })
}

In other words, if the current block is the return target, do what we're currently doing with Return.continue; if not,
do basically the same thing but with Returnable.map instead, and preserve the fact that we're conditional within the
current block, but clear out the preAssignments and change the valueType to the intended output of the block.

*/
