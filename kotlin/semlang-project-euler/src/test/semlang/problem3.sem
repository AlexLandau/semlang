//The prime factors of 13195 are 5, 7, 13 and 29.
//What is the largest prime factor of the number 600851475143 ?

function euler.getLargestPrimeFactor(n: Natural2): Natural2 {
    let primeFactors: List<Natural2> = getPrimeFactors(n)
    let largestPrimeFactor: Natural2 = Try.assume<Natural2>(Natural2.max(primeFactors))
    largestPrimeFactor
}

function getPrimeFactors(n: Natural2): List<Natural2> {
    let primes: Sequence<Natural2> = getPrimes()
    let firstPrimeDivisor: Natural2 = primes->first(dividesEvenly|(_, n))
    if (Natural2.equals(n, firstPrimeDivisor)) {
        [n]<Natural2>
    } else {
        let dividend: Natural2 = Try.assume<Natural2>(Natural2.dividedBy(n, firstPrimeDivisor))
        let recursiveFactors: List<Natural2> = getPrimeFactors(dividend)
        List.append<Natural2>(recursiveFactors, firstPrimeDivisor)
    }
}

// Library candidate for a non-standard library?
function getPrimes(): Sequence<Natural2> {
    let 2: Natural2 = Natural2."2"
    Sequence.createAccumulating<Natural2>(2, getNextPrime|(_))
}

function getNextPrime(allPreviousPrimes: List<Natural2>): Natural2 {
    let lastPrime: Natural2 = Try.assume<Natural2>(List.last<Natural2>(allPreviousPrimes))
    let firstCandidate: Natural2 = Natural2.plus(lastPrime, Natural2."1")
    let candidates: Sequence<Natural2> = Natural2.arithmeticProgression(firstCandidate, Natural2."1")
    candidates->first(isNotDivisibleByAny|(_, allPreviousPrimes))
}

function isNotDivisibleByAny(n: Natural2, allPreviousPrimes: List<Natural2>): Boolean {
    let divisibilities: List<Boolean> = List.map<Natural2, Boolean>(allPreviousPrimes, dividesEvenly|(_, n))
    Boolean.not(Boolean.any(divisibilities))
}

function dividesEvenly(denominator: Natural2, numerator: Natural2): Boolean {
    let remainder: Natural2 = Try.assume<Natural2>(Natural2.modulo(numerator, denominator))
    Natural2.equals(remainder, Natural2."0")
}
