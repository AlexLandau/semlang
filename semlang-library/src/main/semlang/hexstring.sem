
// Represents a non-negative hex value
@Exported
struct HexString {
  string: Unicode.String
  requires {
    Boolean.and(
      Boolean.not(List.isEmpty<Unicode.CodePoint>(string->codePoints)),
      Boolean.all(
        List.map<Unicode.CodePoint, Boolean>(
          string->codePoints,
          isValidHexCodePoint|(_)
        )
      )
    )
  }
}

function getHexCodePointValue(codePoint: Unicode.CodePoint): Try<Natural2> {
  if (Natural2.isBetweenInclusive(codePoint->natural, Natural2."48", Natural2."57")) {
    // Note: In these cases, absoluteDifference() should act as minus().
    // Not sure if this is the right permanent solution.
    Try.success<Natural2>(Natural2.absoluteDifference(codePoint->natural, Natural2."48"))
  } else {
    if (Natural2.isBetweenInclusive(codePoint->natural, Natural2."97", Natural2."102")) {
      Try.success<Natural2>(Natural2.absoluteDifference(codePoint->natural, Natural2."87"))
    } else {
      Try.failure<Natural2>()
    }
  }
}

function isValidHexCodePoint(codePoint: Unicode.CodePoint): Boolean {
  Try.isSuccess<Natural2>(getHexCodePointValue(codePoint))
//  Boolean.or(
//    // Number case: 0-9
//    Natural.isBetweenInclusive(codePoint->natural, Natural."48", Natural."57"),
//    // Letter case: a-f (lowercase only)
//    Natural.isBetweenInclusive(codePoint->natural, Natural."97", Natural."102")
//  )
}

@Exported
function HexString.toValue(hexString: HexString): Natural2 {
  List.reduce<Unicode.CodePoint, Natural2>(
    hexString->string->codePoints,
    Natural2."0",
    hexStringReduction|(_, _)
  )
}

function hexStringReduction(numberSoFar: Natural2, nextCodePoint: Unicode.CodePoint): Natural2 {
  let prefixValue = Natural2.times(numberSoFar, Natural2."16")
  let currentDigitValue = Try.assume<Natural2>(getHexCodePointValue(nextCodePoint))
  Natural2.plus(prefixValue, currentDigitValue)
}

