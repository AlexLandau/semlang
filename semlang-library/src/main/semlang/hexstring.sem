
// Represents a non-negative hex value
@Exported
struct HexString {
  string: Unicode.String
  requires {
    Boolean.and(
      Boolean.not(List.isEmpty<Unicode.CodePoint>(string->codePoints)),
      Boolean.all(
        List.map<Unicode.CodePoint, Boolean>(
          string->codePoints,
          isValidHexCodePoint|(_)
        )
      )
    )
  }
}

function getHexCodePointValue(codePoint: Unicode.CodePoint): Try<Natural> {
  if (Natural.isBetweenInclusive(codePoint->natural, Natural."48", Natural."57")) {
    // Note: In these cases, absoluteDifference() should act as minus().
    // Not sure if this is the right permanent solution.
    Try.success<Natural>(Natural.absoluteDifference(codePoint->natural, Natural."48"))
  } else {
    if (Natural.isBetweenInclusive(codePoint->natural, Natural."97", Natural."102")) {
      Try.success<Natural>(Natural.absoluteDifference(codePoint->natural, Natural."87"))
    } else {
      Try.failure<Natural>()
    }
  }
}

function isValidHexCodePoint(codePoint: Unicode.CodePoint): Boolean {
  Try.isSuccess<Natural>(getHexCodePointValue(codePoint))
//  Boolean.or(
//    // Number case: 0-9
//    Natural.isBetweenInclusive(codePoint->natural, Natural."48", Natural."57"),
//    // Letter case: a-f (lowercase only)
//    Natural.isBetweenInclusive(codePoint->natural, Natural."97", Natural."102")
//  )
}

@Exported
function HexString.toValue(hexString: HexString): Natural {
  List.reduce<Unicode.CodePoint, Natural>(
    hexString->string->codePoints,
    Natural."0",
    hexStringReduction|(_, _)
  )
}

function hexStringReduction(numberSoFar: Natural, nextCodePoint: Unicode.CodePoint): Natural {
  let prefixValue = Natural.times(numberSoFar, Natural."16")
  let currentDigitValue = Try.assume<Natural>(getHexCodePointValue(nextCodePoint))
  Natural.plus(prefixValue, currentDigitValue)
}

