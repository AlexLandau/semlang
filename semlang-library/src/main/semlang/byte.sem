
@Exported
struct Byte {
  value: Natural
  requires {
    Natural.lessThan(value, Natural."256")
  }
}

@Exported
struct ByteBits {
  value: BitsBigEndian
  requires {
    Natural.equals(Natural."8", List.size<Bit>(value->value))
  }
}

@Exported
struct Byte.BitPosition {
  value: Natural
  requires {
    Natural.lessThan(value, Natural."8")
  }
}

@Exported
function Byte.toBits(byte: Byte): ByteBits {
  let bits = Try.assume<BitsBigEndian>(Natural.toNBits(byte->value, Natural."8"))
  Try.assume<ByteBits>(ByteBits(bits))
}

@Exported
function ByteBits.get(bits: ByteBits, bitPosition: Byte.BitPosition): Bit {
  Try.assume<Bit>(List.get<Bit>(bits->value->value, bitPosition->value))
}
