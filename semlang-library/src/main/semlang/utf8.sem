
// This could make an interesting test case for seeing if functions written to work on list-based
// types can be automatically converted to work on streams instead.

/* This version of the function requires the bytes given to correspond exactly to a complete
 * string. If any part of the bytes are invalid, failure will be returned.
 *
 * TODO: This is not actually as strict as desired yet. Disallow overlong encodings, invalid code points,
 * etc. Also add a less-strict parser.
 */
// First implementation is silly recursive approach, just to work out the Byte functions needed.
@Export
function Utf8.decodeStrict1(bytes: List<Byte>): Try<Unicode.String> {
  if (Natural.equals(List.size<Byte>(bytes), Natural."0")) {
    Try.success<Unicode.String>(Unicode.String."")
  } else {
    // TODO: Convert to the newer bytes-to-bits approach
    let firstByte = Try.assume<Byte>(List.get<Byte>(bytes, Natural."0"))
    let firstByteBits = Byte.toBits(firstByte)
    let 128bit = Byte.BitPosition."7"
    if (Bit.equals(Bit."0", ByteBits.get(firstByteBits, Byte.BitPosition."0"))) {
      let firstChar = Try.assume<Unicode.CodePoint>(Unicode.CodePoint(firstByte->natural))
      let remainingBytes = List.drop<Byte>(bytes, Natural."1")
      Try.map<Unicode.String, Unicode.String>(Utf8.decodeStrict1(remainingBytes),
        function(remainingString: Unicode.String) {
          let allChars = List.appendFront<Unicode.CodePoint>(firstChar, remainingString->codePoints)
          Unicode.String(allChars)
        }
      )
    } else {
      let 64bit = Byte.BitPosition."6"
      let 32bit = Byte.BitPosition."5"
      if (Boolean.and(
        Bit.equals(Bit."1", ByteBits.get(firstByteBits, Byte.BitPosition."1")),
        Bit.equals(Bit."0", ByteBits.get(firstByteBits, Byte.BitPosition."2")),
      )) {
        // TODO: Check that we are not the last byte, and that the second byte begins with bits "10"
        let secondByte = Try.assume<Byte>(List.get<Byte>(bytes, Natural."1")) // TODO: Fix assumption
        let secondByteBits = Byte.toBits(secondByte)
        let fullBits = BitsBigEndian(List.concatenate<Bit>(
          List.lastN<Bit>(firstByteBits->bitsBigEndian->bits, Natural."5"),
          List.lastN<Bit>(secondByteBits->bitsBigEndian->bits, Natural."6")
        ))
        let codePointValue = Natural.fromBits(fullBits)
        let firstChar = Try.assume<Unicode.CodePoint>(Unicode.CodePoint(codePointValue))
        let remainingBytes = List.drop<Byte>(bytes, Natural."2")
        Try.map<Unicode.String, Unicode.String>(Utf8.decodeStrict1(remainingBytes),
          function(remainingString: Unicode.String) {
            let allChars = List.appendFront<Unicode.CodePoint>(firstChar, remainingString->codePoints)
            Unicode.String(allChars)
          }
        )
      } else {
        // TODO: Implement
        Try.failure<Unicode.String>()
      }
    }
  }
}
