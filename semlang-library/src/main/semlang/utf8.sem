
// This could make an interesting test case for seeing if functions written to work on list-based
// types can be automatically converted to work on streams instead.

/* This version of the function requires the bytes given to correspond exactly to a complete
 * string. If any part of the bytes are invalid, failure will be returned.
 *
 * TODO: This is not actually as strict as desired yet. Disallow overlong encodings, invalid code points,
 * etc. Also add a less-strict parser.
 */
// First implementation is silly recursive approach, just to work out the Byte functions needed.
@Exported
function Utf8.decodeStrict1(bytes: List<Byte>): Try<Unicode.String> {
  if (Natural.equals(List.size<Byte>(bytes), Natural."0")) {
    Try.success<Unicode.String>(Unicode.String."")
  } else {
    // TODO: Convert to the newer bytes-to-bits approach
    let firstByte = Try.assume<Byte>(List.get<Byte>(bytes, Natural."0"))
    let 128bit = Byte.BitPosition."7"
    if (Boolean.not(Byte.isBit1(firstByte, 128bit))) {
      let firstChar = Try.assume<Unicode.CodePoint>(Unicode.CodePoint(firstByte->value))
      let remainingBytes = List.drop<Byte>(bytes, Natural."1")
      Try.map<Unicode.String, Unicode.String>(Utf8.decodeStrict1(remainingBytes),
        finishStringLambda|(firstChar, _)
      )
    } else {
      let 64bit = Byte.BitPosition."6"
      let 32bit = Byte.BitPosition."5"
      if (Boolean.and(
        Byte.isBit1(firstByte, 64bit),
        Boolean.not(Byte.isBit1(firstByte, 32bit))
      )) {
        // TODO: Check that we are not the last byte, and that the second byte begins with bits "10"
        let secondByte = Try.assume<Byte>(List.get<Byte>(bytes, Natural."1")) // TODO: Fix assumption
        let firstByteBits = Byte.toBits(firstByte)
        let secondByteBits = Byte.toBits(secondByte)
        let fullBits = BitsBigEndian(List.concatenate<Bit>(
          List.lastN<Bit>(firstByteBits->value, Natural."5"),
          List.lastN<Bit>(secondByteBits->value, Natural."6")
        ))
        let codePointValue = Natural.fromBits(fullBits)
        let firstChar = Try.assume<Unicode.CodePoint>(Unicode.CodePoint(codePointValue))
        let remainingBytes = List.drop<Byte>(bytes, Natural."2")
        Try.map<Unicode.String, Unicode.String>(Utf8.decodeStrict1(remainingBytes),
          finishStringLambda|(firstChar, _)
        )
      } else {
        // TODO: Implement
        Try.failure<Unicode.String>()
      }
    }
  }
}

function finishStringLambda(firstChar: Unicode.CodePoint, remainingString: Unicode.String): Unicode.String {
  let allChars = List.appendFront<Unicode.CodePoint>(firstChar, remainingString->value)
  Unicode.String(allChars)
}
