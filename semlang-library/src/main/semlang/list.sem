
@Export
function List.isEmpty<T>(list: List<T>): Boolean {
  Natural.equals(List.size<T>(list), Natural."0")
}

@Export
function List.first<T>(list: List<T>): Try<T> {
  List.get<T>(list, Natural."0")
}

@Export
function List.last<T>(list: List<T>): Try<T> {
  let size = List.size<T>(list)
  let lastIndexMaybe: Try<Natural> = Natural(Natural.minus(size, Natural."1"))
  Try.flatMap<Natural, T>(lastIndexMaybe, function(lastIndex: Natural): Try<T> {
    List.get<T>(list, lastIndex)
  })
}

@Export
function List.nCopies<T>(n: Natural, value: T): List<T> {
  let sequence = Sequence.create<List<T>>([]<T>, List.append<T>|(_, value))
  // TODO: Resimplify this
  sequence->get(n)
}

@Export
function List.drop<T>(list: List<T>, n: Natural): List<T> {
  let end = List.size<T>(list)
  let start = Natural.lesser(n, end)
  Try.assume<List<T>>(List.subList<T>(list, start, end))
}

@Export
function List.dropLast<T>(list: List<T>, n: Natural): List<T> {
  let endMaybe = Natural(Natural.minus(List.size<T>(list), n))
  let end = Try.orElse<Natural>(endMaybe, Natural."0")
  Try.assume<List<T>>(List.subList<T>(list, Natural."0", end))
}

@Export
function List.firstN<T>(list: List<T>, n: Natural): List<T> {
  let end = Natural.lesser(n, List.size<T>(list))
  Try.assume<List<T>>(List.subList<T>(list, Natural."0", end))
}

@Export
function List.lastN<T>(list: List<T>, n: Natural): List<T> {
  let size = List.size<T>(list)
  let startMaybe = Natural(Natural.minus(size, n))
  let start = Try.orElse<Natural>(startMaybe, Natural."0")
  Try.assume<List<T>>(List.subList<T>(list, start, size))
}

@Export
function List.interpose<T>(list: List<T>, interposer: T): List<T> {
  if (List.isEmpty<T>(list)) {
    []<T>
  } else {
    let listWithExtraTrailingItem = List.flatMap<T, T>(list, function (item: T): List<T> {
      [item, interposer]<T>
    })
    List.dropLast<T>(listWithExtraTrailingItem, Natural."1")
  }
}

@Export
function List.getIndices<T>(list: List<T>): List<Natural> {
  let size = List.size<T>(list)
  if (Natural.equals(size, Natural."0")) {
    []<Natural>
  } else {
    let lastIndex = Try.assume<Natural>(Natural(Natural.minus(size, Natural."1")))
    Natural.rangeInclusive(Natural."0", lastIndex)
  }
}

@Export
function List.firstIndexWith<T>(list: List<T>, predicate: (T) -> Boolean): Try<Natural> {
  // TODO: Rewrite this to be iterative
  List.firstIndexWith.helper<T>(list, predicate, Natural."0")
}
function List.firstIndexWith.helper<T>(list: List<T>, predicate: (T) -> Boolean, curIndex: Natural): Try<Natural> {
  let itemMaybe = List.get<T>(list, curIndex)
  Try.flatMap<T, Natural>(itemMaybe, function (item: T): Try<Natural> {
    if (predicate(item)) {
      Try.success<Natural>(curIndex)
    } else {
      let nextIndex = Natural.plus(curIndex, Natural."1")
      List.firstIndexWith.helper<T>(list, predicate, nextIndex)
    }
  })
}

@Export
function List.firstIndexOf<T: Data>(list: List<T>, object: T): Try<Natural> {
  List.firstIndexWith<T>(list, Data.equals<T>|(object, _))
}
