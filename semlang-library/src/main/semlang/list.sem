
@Export
function List.isEmpty<T>(list: List<T>): Boolean {
  Natural.equals(List.size<T>(list), Natural."0")
}

@Export
function List.first<T>(list: List<T>): Try<T> {
  List.get<T>(list, Natural."0")
}

@Export
function List.last<T>(list: List<T>): Try<T> {
  let size = List.size<T>(list)
  let lastIndexMaybe: Try<Natural> = Natural(Natural.minus(size, Natural."1"))
  Try.flatMap<Natural, T>(lastIndexMaybe, function(lastIndex: Natural): Try<T> {
    List.get<T>(list, lastIndex)
  })
}

@Export
function List.nCopies<T>(n: Natural, value: T): List<T> {
  let sequence = Sequence.create<List<T>>([]<T>, List.append<T>|(_, value))
  // TODO: Resimplify this
  sequence->get(n)
}

@Export
function List.drop<T>(list: List<T>, n: Natural): List<T> {
  let end = List.size<T>(list)
  let start = Natural.lesser(n, end)
  Try.assume<List<T>>(List.subList<T>(list, start, end))
}

@Export
function List.dropLast<T>(list: List<T>, n: Natural): List<T> {
  let endMaybe = Natural(Natural.minus(List.size<T>(list), n))
  let end = Try.orElse<Natural>(endMaybe, Natural."0")
  Try.assume<List<T>>(List.subList<T>(list, Natural."0", end))
}

@Export
function List.firstN<T>(list: List<T>, n: Natural): List<T> {
  let end = Natural.lesser(n, List.size<T>(list))
  Try.assume<List<T>>(List.subList<T>(list, Natural."0", end))
}

@Export
function List.lastN<T>(list: List<T>, n: Natural): List<T> {
  let size = List.size<T>(list)
  let startMaybe = Natural(Natural.minus(size, n))
  let start = Try.orElse<Natural>(startMaybe, Natural."0")
  Try.assume<List<T>>(List.subList<T>(list, start, size))
}
