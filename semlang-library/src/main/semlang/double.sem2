@Export
struct Double {
  sign: Double.SignBit
  exponent: Double.Exponent
  fraction: Double.Fraction
}

@Export
struct Double.SignBit {
  bit: Bit
}

@Export
struct Double.Exponent {
  natural: Natural
  requires {
    Natural.lessThan(natural, Natural."2048")
  }
}

@Export
struct Double.Fraction {
  natural: Natural
  requires {
    Natural.lessThan(natural, Natural."9007199254740992")
  }
}

@Export
function Double.toBits(double: Double): BitsBigEndian {
  let bits = ListBuilder<Bit>()
  bits.append(double->sign->bit)
  bits.appendAll(Maybe.assume(Natural.toNBits(double.exponent.natural, Natural."11"))->bits)
  bits.appendAll(Maybe.assume(Natural.toNBits(double.fraction.natural, Natural."52"))->bits)
  BitsBigEndian(ListBuilder.build(bits))
}
 
@Export
function Double.fromBits(bits: BitsBigEndian): Maybe<Double> {
  if (Natural.notEquals(List.size(bits->bits), Natural."64")) {
    Maybe.failure<Double>()
  } else {
    let signBit = Double.SignBit(Maybe.assume(List.get(bits->bits, Natural."0")))
    let exponentBits = Maybe.assume(List.subList(bits->bits, Natural."1", Natural."12"))
    let exponent = Maybe.assume(Double.Exponent(Natural.fromBits(BitsBigEndian(exponentBits))))
    let fractionBits = Maybe.assume(List.subList(bits->bits, Natural."12", Natural."64"))
    let fraction = Maybe.assume(Double.Fraction(Natural.fromBits(BitsBigEndian(fractionBits))))
    Maybe.success(Double(signBit, exponent, fraction))
  }
}

// function Double.parse(string: Unicode.String): Double {

// }

// function Double.toString(double: Double): Unicode.String {

// }

/*
    static FloatingDecimal.ASCIIToBinaryConverter readJavaFormatString(String var0) throws NumberFormatException {
        boolean var1 = false;
        boolean var2 = false;

        try {
            var0 = var0.trim();
            int var5 = var0.length();
            if (var5 == 0) {
                throw new NumberFormatException("empty String");
            }

            int var6 = 0;
            switch(var0.charAt(var6)) {
            case '-':
                var1 = true;
            case '+':
                ++var6;
                var2 = true;
            }

            char var4 = var0.charAt(var6);
            if (var4 == 'N') {
                if (var5 - var6 == NAN_LENGTH && var0.indexOf("NaN", var6) == var6) {
                    return A2BC_NOT_A_NUMBER;
                }
            } else if (var4 == 'I') {
                if (var5 - var6 == INFINITY_LENGTH && var0.indexOf("Infinity", var6) == var6) {
                    return var1 ? A2BC_NEGATIVE_INFINITY : A2BC_POSITIVE_INFINITY;
                }
            } else {
                if (var4 == '0' && var5 > var6 + 1) {
                    char var7 = var0.charAt(var6 + 1);
                    if (var7 == 'x' || var7 == 'X') {
                        return parseHexString(var0);
                    }
                }

                char[] var21 = new char[var5];
                int var8 = 0;
                boolean var9 = false;
                int var10 = 0;
                int var11 = 0;

                int var12;
                for(var12 = 0; var6 < var5; ++var6) {
                    var4 = var0.charAt(var6);
                    if (var4 == '0') {
                        ++var11;
                    } else {
                        if (var4 != '.') {
                            break;
                        }

                        if (var9) {
                            throw new NumberFormatException("multiple points");
                        }

                        var10 = var6;
                        if (var2) {
                            var10 = var6 - 1;
                        }

                        var9 = true;
                    }
                }

                for(; var6 < var5; ++var6) {
                    var4 = var0.charAt(var6);
                    if (var4 >= '1' && var4 <= '9') {
                        var21[var8++] = var4;
                        var12 = 0;
                    } else if (var4 == '0') {
                        var21[var8++] = var4;
                        ++var12;
                    } else {
                        if (var4 != '.') {
                            break;
                        }

                        if (var9) {
                            throw new NumberFormatException("multiple points");
                        }

                        var10 = var6;
                        if (var2) {
                            var10 = var6 - 1;
                        }

                        var9 = true;
                    }
                }

                var8 -= var12;
                boolean var13 = var8 == 0;
                if (!var13 || var11 != 0) {
                    int var3;
                    if (var9) {
                        var3 = var10 - var11;
                    } else {
                        var3 = var8 + var12;
                    }

                    if (var6 < var5 && ((var4 = var0.charAt(var6)) == 'e' || var4 == 'E')) {
                        byte var14 = 1;
                        int var15 = 0;
                        int var16 = 214748364;
                        boolean var17 = false;
                        ++var6;
                        int var18;
                        switch(var0.charAt(var6)) {
                        case '-':
                            var14 = -1;
                        case '+':
                            ++var6;
                        default:
                            var18 = var6;
                        }

                        while(var6 < var5) {
                            if (var15 >= var16) {
                                var17 = true;
                            }

                            var4 = var0.charAt(var6++);
                            if (var4 < '0' || var4 > '9') {
                                --var6;
                                break;
                            }

                            var15 = var15 * 10 + (var4 - 48);
                        }

                        int var19 = 324 + var8 + var12;
                        if (!var17 && var15 <= var19) {
                            var3 += var14 * var15;
                        } else {
                            var3 = var14 * var19;
                        }

                        if (var6 == var18) {
                            throw new NumberFormatException("For input string: \"" + var0 + "\"");
                        }
                    }

                    if (var6 >= var5 || var6 == var5 - 1 && (var0.charAt(var6) == 'f' || var0.charAt(var6) == 'F' || var0.charAt(var6) == 'd' || var0.charAt(var6) == 'D')) {
                        if (var13) {
                            return var1 ? A2BC_NEGATIVE_ZERO : A2BC_POSITIVE_ZERO;
                        }

                        return new FloatingDecimal.ASCIIToBinaryBuffer(var1, var3, var21, var8);
                    }
                }
            }
        } catch (StringIndexOutOfBoundsException var20) {
            ;
        }

        throw new NumberFormatException("For input string: \"" + var0 + "\"");
    }
*/