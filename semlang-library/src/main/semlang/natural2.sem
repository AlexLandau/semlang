@Exported
function Natural2.plus(left: Natural2, right: Natural2): Natural2 {
  Try.assume<Natural2>(Natural2(Integer.plus(left->integer, right->integer)))
}

@Exported
function Natural2.minus(left: Natural2, right: Natural2): Integer {
  Integer.minus(left->integer, right->integer)
}

@Exported
function Natural2.times(left: Natural2, right: Natural2): Natural2 {
  Try.assume<Natural2>(Natural2(Integer.times(left->integer, right->integer)))
}

@Exported
function Natural2.dividedBy(left: Natural2, right: Natural2): Try<Natural2> {
  let divisionResult: Try<Integer> = Integer.dividedBy(left->integer, right->integer)
  Try.flatMap<Integer, Natural2>(divisionResult, Natural2|(_))
}

@Exported
function Natural2.modulo(left: Natural2, right: Natural2): Try<Natural2> {
  let moduloResult: Try<Integer> = Integer.modulo(left->integer, right->integer)
  Try.flatMap<Integer, Natural2>(moduloResult, Natural2|(_))
}

@Exported
function Natural2.equals(left: Natural2, right: Natural2): Boolean {
  Integer.equals(left->integer, right->integer)
}

@Exported
function Natural2.lessThan(left: Natural2, right: Natural2): Boolean {
  Integer.lessThan(left->integer, right->integer)
}

@Exported
function Natural2.greaterThan(left: Natural2, right: Natural2): Boolean {
  Integer.greaterThan(left->integer, right->integer)
}

@Exported
function Natural2.isBetweenInclusive(toCheck: Natural2, lowerBound: Natural2, upperBound: Natural2): Boolean {
  Boolean.and(
    Natural2.lessThanOrEqualTo(lowerBound, toCheck),
    Natural2.lessThanOrEqualTo(toCheck, upperBound)
  )
}

@Exported
function Natural2.lessThanOrEqualTo(left: Natural2, right: Natural2): Boolean {
  if (Natural2.lessThan(left, right)) {
    Boolean."true"
  } else {
    Natural2.equals(left, right)
  }
}

@Exported
function Natural2.lesser(left: Natural2, right: Natural2): Natural2 {
  if (Natural2.lessThan(left, right)) {
    left
  } else {
    right
  }
}

@Exported
function Natural2.greater(left: Natural2, right: Natural2): Natural2 {
  if (Natural2.greaterThan(left, right)) {
    left
  } else {
    right
  }
}

@Exported
function Natural2.max(naturals: List<Natural2>): Try<Natural2> {
  let firstValueMaybe = List.first<Natural2>(naturals)
  Try.map<Natural2, Natural2>(firstValueMaybe, function(firstValue: Natural2) {
    List.reduce<Natural2, Natural2>(naturals, firstValue, Natural2.greater|(_, _))
  })
}

@Exported
function Natural2.absoluteDifference(left: Natural2, right: Natural2): Natural2 {
  let difference = Integer.minus(left->integer, right->integer)
  Natural2.absoluteValue(difference)
}

@Exported
function Natural2.absoluteValue(integer: Integer): Natural2 {
  let integerValue = if (Integer.lessThan(integer, Integer."0")) {
    Integer.minus(Integer."0", integer)
  } else {
    integer
  }
  Try.assume<Natural2>(Natural2(integerValue))
}

@Exported
function Natural2.toNBits(value: Natural2, numBits: Natural2): Try<BitsBigEndian> {
  let allBits = if (Natural2.equals(value, Natural2."0")) {
    []<Bit>
  } else {
    Natural2.toBits(value)->bits
  }
  let actualNumBits = List.size<Bit>(allBits)
  let paddingNeededMaybe = Natural2(Natural2.minus(numBits, actualNumBits))
  Try.map<Natural2, BitsBigEndian>(paddingNeededMaybe, function(paddingNeeded: Natural2) {
    let padding = List.nCopies<Bit>(paddingNeeded, Bit."0")
    BitsBigEndian(List.concatenate<Bit>(padding, allBits))
  })
}

// TODO: You really want this to be done natively...
@Exported
function Natural2.toBits(value: Natural2): BitsBigEndian {
  if (Natural2.equals(value, Natural2."0")) {
    BitsBigEndian([Bit."0"]<Bit>)
  } else {
    BitsBigEndian(Natural2.toBitsList(value))
  }
}
function Natural2.toBitsList(value: Natural2): List<Bit> {
  // TODO: This can probably be done better/non-recursively
  if (Natural2.equals(value, Natural2."0")) {
    []<Bit>
  } else {
    let listWithoutLastBit = Natural2.toBitsList(Try.assume<Natural2>(Natural2.dividedBy(value, Natural2."2")))
    let curBit = Try.assume<Bit>(Bit(Try.assume<Natural2>(Natural2.modulo(value, Natural2."2"))))
    List.append<Bit>(listWithoutLastBit, curBit)
  }
}

// TODO: You really want this to be done natively...
@Exported
function Natural2.fromBits(bitsBigEndian: BitsBigEndian): Natural2 {
  List.reduce<Bit, Natural2>(bitsBigEndian->bits, Natural2."0", function(valueSoFar: Natural2, bit: Bit) {
    let doubledValue = Natural2.times(valueSoFar, Natural2."2")
    Natural2.plus(doubledValue, bit->natural)
  })
}

// TODO: Move this somewhere appropriate?
@Exported
function Natural2.sum(numbers: List<Natural2>): Natural2 {
  List.reduce<Natural2, Natural2>(numbers, Natural2."0", Natural2.plus|(_, _))
}

@Exported
function Natural2.rangeInclusive(start: Natural2, end: Natural2): List<Natural2> {
  let numberOfValuesMaybe = Natural2(Natural2.minus(Natural2.plus(end, Natural2."1"), start))
  let rangeMaybe = Try.map<Natural2, List<Natural2>>(numberOfValuesMaybe, function(numValues: Natural2) {
    Sequence.getRange<Natural2>(Natural2.arithmeticProgression(start, Natural2."1"), numValues)
  })
  Try.orElse<List<Natural2>>(rangeMaybe, []<Natural2>)
}

@Exported
function Natural2.sequence(): Sequence<Natural2> {
  Sequence.create<Natural2>(Natural2."0", Natural2.plus|(_, Natural2."1"))
}

@Exported
function Natural2.arithmeticProgression(initialValue: Natural2, increment: Natural2): Sequence<Natural2> {
  Sequence.create<Natural2>(initialValue, Natural2.plus|(_, increment))
}
