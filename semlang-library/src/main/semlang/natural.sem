
@Exported
function Natural.sequence(): Sequence<Natural> {
    Sequence.create<Natural>(Natural."0", Natural.plus|(_, Natural."1"))
}

@Exported
function Natural.arithmeticProgression(initialValue: Natural, increment: Natural): Sequence<Natural> {
    Sequence.map<Natural, Natural>(Natural.sequence(), Natural.internal.plusProduct|(initialValue, increment, _))
}
function Natural.internal.plusProduct(a: Natural, b: Natural, c: Natural): Natural {
    Natural.plus(a, Natural.times(b, c))
}

@Exported
function Natural.isBetweenInclusive(toCheck: Natural, lowerBound: Natural, upperBound: Natural): Boolean {
    Boolean.and(
        Natural.lessThanOrEqualTo(lowerBound, toCheck),
        Natural.lessThanOrEqualTo(toCheck, upperBound)
    )
}

@Exported
function Natural.minus(left: Natural, right: Natural): Try<Natural> {
  Natural.fromInteger(Integer.minus(Integer.fromNatural(left), Integer.fromNatural(right)))
}
