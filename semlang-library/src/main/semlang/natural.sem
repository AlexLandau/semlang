
@Exported
function Natural.sequence(): Sequence<Natural> {
    Sequence.create<Natural>(Natural."0", Natural.plus|(_, Natural."1"))
}

@Exported
function Natural.arithmeticProgression(initialValue: Natural, increment: Natural): Sequence<Natural> {
    Sequence.map<Natural, Natural>(Natural.sequence(), Natural.internal.plusProduct|(initialValue, increment, _))
}
function Natural.internal.plusProduct(a: Natural, b: Natural, c: Natural): Natural {
    Natural.plus(a, Natural.times(b, c))
}

@Exported
function Natural.isBetweenInclusive(toCheck: Natural, lowerBound: Natural, upperBound: Natural): Boolean {
    Boolean.and(
        Natural.lessThanOrEqualTo(lowerBound, toCheck),
        Natural.lessThanOrEqualTo(toCheck, upperBound)
    )
}

@Exported
function Natural.lessThanOrEqualTo(left: Natural, right: Natural): Boolean {
  if (Natural.lessThan(left, right)) {
    Boolean."true"
  } else {
    Natural.equals(left, right)
  }
}

@Exported
function Natural.greaterThanOrEqualTo(left: Natural, right: Natural): Boolean {
  if (Natural.greaterThan(left, right)) {
    Boolean."true"
  } else {
    Natural.equals(left, right)
  }
}

@Exported
function Natural.toNBits(value: Natural, numBits: Natural2): Try<BitsBigEndian> {
  let allBits = if (Natural.equals(value, Natural."0")) {
    []<Bit>
  } else {
    Natural.toBits(value)->bits
  }
  let actualNumBits = List.size<Bit>(allBits)
  let paddingNeededMaybe = Natural2(Natural2.minus(numBits, actualNumBits))
  Try.map<Natural2, BitsBigEndian>(paddingNeededMaybe, function(paddingNeeded: Natural2) {
    let padding = List.nCopies<Bit>(paddingNeeded, Bit."0")
    BitsBigEndian(List.concatenate<Bit>(padding, allBits))
  })
}
