
@Exported
function Natural.sequence(): Sequence<Natural> {
    Sequence.create<Natural>(Natural."0", Natural.plus|(_, Natural."1"))
}

@Exported
function Natural.arithmeticProgression(initialValue: Natural, increment: Natural): Sequence<Natural> {
    Sequence.map<Natural, Natural>(Natural.sequence(), Natural.internal.plusProduct|(initialValue, increment, _))
}
function Natural.internal.plusProduct(a: Natural, b: Natural, c: Natural): Natural {
    Natural.plus(a, Natural.times(b, c))
}

@Exported
function Natural.isBetweenInclusive(toCheck: Natural, lowerBound: Natural, upperBound: Natural): Boolean {
    Boolean.and(
        Natural.lessThanOrEqualTo(lowerBound, toCheck),
        Natural.lessThanOrEqualTo(toCheck, upperBound)
    )
}

@Exported
function Natural.lessThanOrEqualTo(left: Natural, right: Natural): Boolean {
  if (Natural.lessThan(left, right)) {
    Boolean."true"
  } else {
    Natural.equals(left, right)
  }
}

@Exported
function Natural.greaterThanOrEqualTo(left: Natural, right: Natural): Boolean {
  if (Natural.greaterThan(left, right)) {
    Boolean."true"
  } else {
    Natural.equals(left, right)
  }
}
