
// Strictly speaking, this could be a struct, but it's a good first test
// (Situtations where it's really necessary can get kind of hairy)

interface myCode.NaturalOperator {
    getIdentity(): Natural
    apply(left: Natural, right: Natural): Natural
}

@Test("['1', '1']: '2'")
@Test("['3', '6']: '45'")
@Test("['9', '0']: '81'")
@Test("['6', '8']: '100'")
@Test("['2', '5']: '29'")
function myCode.squareDistance(a: Natural, b: Natural): Natural {
    let plusOperator: myCode.NaturalOperator = getPlusOperator()
    let timesOperator: myCode.NaturalOperator = getTimesOperator()
    let aSquared: Natural = timesOperator->apply(a, a)
    let bSquared: Natural = selfApply(timesOperator, b)
    plusOperator->apply(aSquared, bSquared)
}

function selfApply(operator: myCode.NaturalOperator, value: Natural): Natural {
    operator->apply(value, value)
}

function getPlusOperator(): myCode.NaturalOperator {
    myCode.NaturalOperator<Natural>(Natural."0", getNaturalOperatorAdapter(implPlus|(_, _, _)))
}

// TODO: Someday add a library function for this?
function implGetIdentity(identity: Natural): Natural {
    identity
}

// TODO: Do something with lambda expressions that prevents us from needing this
function implPlus(identity: Natural, left: Natural, right: Natural): Natural {
    Natural.plus(left, right)
}

function getTimesOperator(): myCode.NaturalOperator {
    myCode.NaturalOperator<Natural>(Natural."1", getNaturalOperatorAdapter(implTimes|(_, _, _)))
}

function getNaturalOperatorAdapter(applyMethod: (Natural, Natural, Natural) -> Natural): myCode.NaturalOperator.Adapter<Natural> {
    myCode.NaturalOperator.Adapter<Natural>(implGetIdentity|(_), applyMethod)
}

function implTimes(identity: Natural, left: Natural, right: Natural): Natural {
    Natural.times(left, right)
}
