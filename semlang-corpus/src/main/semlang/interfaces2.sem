
// Strictly speaking, this could be a struct, but it's a good first test
// (Situtations where it's really necessary can get kind of hairy)

interface myCode.IntegerOperator {
    getIdentity(): Integer
    apply(left: Integer, right: Integer): Integer
}

@Test(["1", "1"], "2")
@Test(["3", "6"], "45")
@Test(["9", "0"], "81")
@Test(["6", "8"], "100")
@Test(["2", "5"], "29")
function myCode.squareDistance(a: Integer, b: Integer): Integer {
    let plusOperator: myCode.IntegerOperator = getPlusOperator()
    let timesOperator: myCode.IntegerOperator = getTimesOperator()
    let aSquared: Integer = timesOperator->apply(a, a)
    let bSquared: Integer = selfApply(timesOperator, b)
    plusOperator->apply(aSquared, bSquared)
}

function selfApply(operator: myCode.IntegerOperator, value: Integer): Integer {
    // Throw in a function binding, just because we can
    let applyOnce: (Integer) -> Integer = operator->apply|(value, _)
    applyOnce(value)
}

function getPlusOperator(): myCode.IntegerOperator {
    myCode.IntegerOperator<Integer>(Integer."0", getIntegerOperatorAdapter(implPlus|(_, _, _)))
}

// TODO: Someday add a library function for this?
function implGetIdentity(identity: Integer): Integer {
    identity
}

// TODO: Do something with lambda expressions that prevents us from needing this
function implPlus(identity: Integer, left: Integer, right: Integer): Integer {
    Integer.plus(left, right)
}

function getTimesOperator(): myCode.IntegerOperator {
    myCode.IntegerOperator<Integer>(Integer."1", getIntegerOperatorAdapter(implTimes|(_, _, _)))
}

function getIntegerOperatorAdapter(applyMethod: (Integer, Integer, Integer) -> Integer): myCode.IntegerOperator.Adapter<Integer> {
    myCode.IntegerOperator.Adapter<Integer>(implGetIdentity|(_), applyMethod)
}

function implTimes(identity: Integer, left: Integer, right: Integer): Integer {
    Integer.times(left, right)
}
