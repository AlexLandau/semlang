- Clean up, organize code and sample Semlang code
  - Make things private when they can be
  - Rewrite NativeFunctions implementations with as?/?: for casting
  - Turn NativeFunctions into library code written in semlang where possible
  - Use a code coverage tool for the Kotlin tests
- Inform Gradle that the kotlin-parser tests depend on the src/test/semlang folder
- Have a list somewhere of the exposed methods that are intentionally "API"-ish
- Test block comment parsing, line comments at end of files
- Validator: Write more simple positive tests and negative tests
  - Try to squeeze out the obvious possibilities of wrongness
- Backwards-chaining interpreter; performance testing and output comparisons for forward, backward interpreters
  - Write some cases where this should skip actual work, check that it works as expected
- Finish up static validation TODOs
  - Validate struct member names
  - Validate function argument names
  - Make code style more consistent
- Function definitions as tests
- Can we remove TypedExpression.NamedFunctionBinding#chosenParameters?
- Support function bindings of struct constructors
- Support function bindings of interface constructors
- Support e.g. foo->bar() calls and foo->bar|() bindings directly, if the parser doesn't hate it
- List type (firstIndex, map)
- Interpreter: Test that all native functions defined in the API have implementations in the interpreter
- Additional primitive types (N-bit integers, strings, characters, floating-point numbers, rationals?)
- Enum types
- Real package/module declarations and use, including "import as" (note: "import as" could be a dialect/transformation)
- Code writing into Java
- Annotations and multiple function definitions
- Interfaces/instances
- Monads (e.g. start with support for console-out)
- Gradle manipulation of Semlang (i.e. beginnings of a build system)
- Real IDE-like editor environment
- Start to create dialects with simpler syntax, type inference, etc.
  - "sem1" vs. "sem0" for starters
  - Also type inference for parameters when calling functions, for types that can be inferred (can these be separated somehow?)
  - Some sort of lambda expressions would be really nice...
- Semlang -> Semlang transformations, optimizations, etc.
  - Use only simple (non-nested) expressions
  - Remove redundant variables and reiterated definitions
  - Ground all uses of generics within a program, so a parser can just treat it as an extension of the identifier
  - Turn interface definitions into their constituents
  - Function differentials
  - Compute approximate worst-case computational time of a function, given specific inputs (value is N -> worst-case actual time is O(N))
  - Given a T -> T function, turn it into a T -> Boolean that returns whether the input would be turned into itself
- Port "code writing into Java" to Semlang

Design choices to reconsider:
- Alternative keyword to "return" that better reflects how it's used in blocks in general?
  - "use", "choose", "be", "select"
- Figure out what to do about recursive function calls
- Integer.fromNatural or Natural.toInteger?
- Try failure: Include ways to distinguish sources of errors? (Union types for exception types?)
  - Stacktraces for debugging are considered outside the semantics of Semlang, and so are not included in the type system.
- Consider moving <T> in function definition to after name

Probable dependencies of the type work:
- Function types/references depending on tuples
- Sequences depending on function references
- Interfaces depending on function references

As things are completed:
- Project Euler
- http://benchmarksgame.alioth.debian.org/

Less important, orthogonal to-dos:
- Clean up Gradle builds
- Consistent naming convention for .kt files
