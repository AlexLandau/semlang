- Clean up, organize code and sample Semlang code
  - Make things private when they can be
  - Turn NativeFunctions into library code written in semlang where possible
    - It would also be nice to have this in some .class form in a produced .jar, maybe?
  - Use a code coverage tool for the Kotlin tests
- Thoughts on code corpus:
  - These are groups of code that include annotations or comments with their intended output for given inputs
  - Thus, any implementation can use them as a test of that implementation
  - One corpus for the language basics and required native methods
  - Another corpus for the "standard library"
  - These can get their own semantic versioning; essentially, adding tests is a patch version change,
    adding a new feature to be implemented is a minor version change, and breaking the API is a major
    version change (so basically, give it the same version as the API itself)
  - In turn, we probably want to have a standard artifact format (even if it's just a .tgz or .zip
    of the source files) for ease of distribution via a Maven-like system
  - Should probably find a more pleasant-sounding word than "corpus"
- Have a list somewhere of the exposed methods that are intentionally "API"-ish
- Validator: Write more simple positive tests and negative tests
  - Try to squeeze out the obvious possibilities of wrongness
- Backwards-chaining interpreter; performance testing and output comparisons for forward, backward interpreters
  - Write some cases where this should skip actual work, check that it works as expected
- Finish up static validation TODOs
  - Validate struct member names
  - Validate function argument names
  - Make code style more consistent
- Support function bindings of instance constructors and adapter constructors
- List#firstIndex
- Interpreter: Test that all native functions defined in the API have implementations in the interpreter
- Additional primitive types (N-bit integers, floating-point numbers, rationals?)
- String library methods
- Enum types
  - Might be a concept combinable with union types (like ADTs)?
- DSL for "selecting" expressions from anywhere in a function
  - Point is to establish this before considering add'l characters in variable names
  - Use with Try.assert for an "Assertable" annotation? (e.g. for min or max, a list where size is >0)
- Real package/module declarations and use, including "import as" (note: "import as" could be a dialect/transformation)
- Code writing into Java
  - We should have some way to specify the exposed API, and check the inputs of these methods for e.g. Natural >= 0
  - Probably put all our code from one module into the same package
- Annotations and multiple function definitions
- Monads (e.g. start with support for console-out)
- Gradle manipulation of Semlang (i.e. beginnings of a build system)
- Real IDE-like editor environment
- Interactive debugger of functions: drill down into results of subcalls
  - Mark results of specific functions as correct or incorrect for recording tests
  - Set up "normal" interpreter to record the results of specific functions; bridge into this after-the-fact analysis
    - (Record any non-determinism from monads while inside such a call)
- Offer alternative syntax with even easier parsing (e.g. commas prepended to lists, dots prepended to IDs)
- Start to create dialects with simpler syntax, type inference, etc.
  - "sem1" vs. "sem0" for starters
  - Also type inference for parameters when calling functions, for types that can be inferred (can these be separated somehow?)
  - Some sort of lambda expressions would be really nice...
- Semlang -> Semlang transformations, optimizations, etc.
  - Use only simple (non-nested) expressions
  - Remove redundant variables and reiterated definitions
  - Ground all uses of generics within a program, so a parser can just treat it as an extension of the identifier
  - Turn interface definitions into their constituents
  - Function differentials
  - Compute approximate worst-case computational time of a function, given specific inputs (value is N -> worst-case actual time is O(N))
  - Given a T -> T function, turn it into a T -> Boolean that returns whether the input would be turned into itself
- Port "code writing into Java" to Semlang

Figuring out packages and a module system:
  - I suspect that the JavaScript/npm module system is closer to what we want than the Java system (in its original
    form). Certainly we want the nice property of code exposing a fully controlled API and not its dependencies, as
    well as (related) including multiple
    - Related nice-to-have: Renaming types as they are imported.
  - It's worth researching Cargo here as well, as that system is recent and seems highly respected.
  - It would be nice to allow:
    - Specification of a target library within a source file (with the caveat that we want this in a centralized list
      in most places)
    - Specification of a cryptographic hash whenever we specify a dependency, to require that the version we pull in
      match the hash (for security's sake)
  - I think we want to be able to pull in imports from libraries
  - We'll have to figure out some way to deal with this when exporting to other languages, like Java. That could mean
    e.g. heavy use of shadowing, and/or the Java 9 build system.
  - Mandatory namespacing of e.g. "com.google.guava" or "google:guava" seems better than npm's free-for-all of first-tier
    names
  - Automatic semantic versioning would be awesome, but I don't know what that would look like yet.
    - I took a look at Elm and their version treats "function returns a different value" as a patch change, so I don't
      think that's sufficient (unless programmers are very, very well-behaved).
So a first pass would look like:
  - Groups of self-contained code are organized as modules, and have dependencies on other modules that by default are
    non-transitive (transitivity could be added later, in the form of re-declarations or otherwise).
  - Distribution/publication of modules online will happen at some point, but currently is TBD. Until then, we should
    probably allow internal repositories on a device (as some other repositories allow). In fact, it may be preferable
    to require use of such an internal repository as an intermediary in both directions (like a git repo). Caching on
    the way in, atomicity of publication (?) on the way out. Regardless of if we take that approach, this increases the
    similarity of formats between the systems.
    - So, we'll want a file format/directory structure for the published modules.
      - Probably at ~/.semlang/repo-1/ or the equivalent thereof, "-1" allowing for a future "-2" format, etc.
  - Code should probably be stored in whatever format is densest and/or most valuable for automated use. Of course, we
    will end up retaining comments (once they become annotations) and the like anyway...
  - We're already using namespacing for *.Adapter and it would make sense for closely related types (as seen in TS), so
    it shouldn't go away entirely, but "package" might be the wrong term now. It should probably be "namespace" and
    reserved for special cases within code, vs. including the org name, module name, etc. as seen in Java.
  - What does testing for this look like?

Design choices to reconsider:
- Figure out what to do about recursive function calls
- Try failure: Include ways to distinguish sources of errors? (Union types for exception types?)
  - Stacktraces for debugging are considered outside the semantics of Semlang, and so are not included in the type system.
- Questionable or inconsistent native functions
  - Integer.fromNatural or Natural.toInteger?
- Slightly alternative semantics: A function ID is an expression representing a function binding for that function with
  empty bindings; this would simplify "named" vs. "expression" calls, but there would (still) be ambiguities between
  function IDs with no package and variables, and this would have to be sussed out in most transpilations.
- Use dot for follow and forward slash for ID separator? (Probably looks better with imports, worse without)
  - There might be a better version of this with the scope of namespaces more limited
- Probably rename the existing "Package" concept to "Namespace"

As things are completed:
- Project Euler
- http://benchmarksgame.alioth.debian.org/

Less important, orthogonal to-dos:
- Clean up Gradle builds
- Consistent naming convention for .kt files
