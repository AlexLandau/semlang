- Clean up, organize code and sample Semlang code
  - Make things private when they can be
- Inform Gradle that the kotlin-parser tests depend on the src/test/semlang folder
- Have a list somewhere of the exposed methods that are intentionally "API"-ish
- Validator: Write more simple positive tests and negative tests
  - Try to squeeze out the obvious possibilities of wrongness
- Backwards-chaining interpreter; performance testing and output comparisons for forward, backward interpreters
  - Write some cases where this should skip actual work, check that it works as expected
- Finish up static validation TODOs
  - Validate struct member names
  - Validate function argument names
  - Make code style more consistent
- Function definitions as tests
- Function reference types
  - Also, don't rule out support for currying (e.g. as needed for a "compose" method)
- List type (index, map, reduce)
- Sequences and "first"
- Additional primitive types (N-bit integers, strings, characters, floating-point numbers, rationals?)
- Enum types
- Real package/module declarations and use, including "import as" (note: "import as" could be a dialect)
- Code writing into Java
- Annotations and multiple function definitions
- Interfaces/instances
- Monads (e.g. start with support for console-out)
- Real IDE-like editor environment
- Start to create dialects with simpler syntax, type inference, etc.
- Semlang -> Semlang optimizations, etc.
- Port "code writing into Java" to Semlang

Design choices to reconsider:
- Alternative keyword to "return" that better reflects how it's used in blocks in general?
  - "use", "choose", "be", "select"
- Figure out what to do about recursive function calls

Probable dependencies of the type work:
- Function types/references depending on tuples
- Sequences depending on function references
- Interfaces depending on function references

As things are completed:
- Project Euler
- http://benchmarksgame.alioth.debian.org/
