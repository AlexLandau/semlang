- Clean up, organize code and sample Semlang code
  - Make things private when they can be
  - Turn NativeFunctions into library code written in semlang where possible
    - It would also be nice to have this in some .class form in a produced .jar, maybe?
  - Use a code coverage tool for the Kotlin tests
- Thoughts on code corpus:
  - These are groups of code that include annotations or comments with their intended output for given inputs
  - Thus, any implementation can use them as a test of that implementation
  - One corpus for the language basics and required native methods
  - Another corpus for the "standard library"
  - These can get their own semantic versioning; essentially, adding tests is a patch version change,
    adding a new feature to be implemented is a minor version change, and breaking the API is a major
    version change (so basically, give it the same version as the API itself)
  - In turn, we probably want to have a standard artifact format (even if it's just a .tgz or .zip
    of the source files) for ease of distribution via a Maven-like system
  - Should probably find a more pleasant-sounding word than "corpus"
- Inform Gradle that the kotlin-parser tests depend on the src/test/semlang folder
- Have a list somewhere of the exposed methods that are intentionally "API"-ish
- Validator: Write more simple positive tests and negative tests
  - Try to squeeze out the obvious possibilities of wrongness
- Backwards-chaining interpreter; performance testing and output comparisons for forward, backward interpreters
  - Write some cases where this should skip actual work, check that it works as expected
- Finish up static validation TODOs
  - Validate struct member names
  - Validate function argument names
  - Make code style more consistent
- Function definitions as tests
- Support function bindings of struct constructors
- Support function bindings of interface constructors
- List#firstIndex
- Interpreter: Test that all native functions defined in the API have implementations in the interpreter
- Additional primitive types (N-bit integers, strings, characters, floating-point numbers, rationals?)
- Enum types
- DSL for "selecting" expressions from anywhere in a function
  - Point is to establish this before considering add'l characters in variable names
  - Use with Try.assert for an "Assertable" annotation? (e.g. for min or max, a list where size is >0)
- Real package/module declarations and use, including "import as" (note: "import as" could be a dialect/transformation)
- Code writing into Java
- Annotations and multiple function definitions
- Monads (e.g. start with support for console-out)
- Gradle manipulation of Semlang (i.e. beginnings of a build system)
- Real IDE-like editor environment
- Interactive debugger of functions: drill down into results of subcalls
  - Mark results of specific functions as correct or incorrect for recording tests
  - Set up "normal" interpreter to record the results of specific functions; bridge into this after-the-fact analysis
    - (Record any non-determinism from monads while inside such a call)
- Offer alternative syntax with even easier parsing (e.g. commas prepended to lists, dots prepended to IDs)
- Start to create dialects with simpler syntax, type inference, etc.
  - "sem1" vs. "sem0" for starters
  - Also type inference for parameters when calling functions, for types that can be inferred (can these be separated somehow?)
  - Some sort of lambda expressions would be really nice...
- Semlang -> Semlang transformations, optimizations, etc.
  - Use only simple (non-nested) expressions
  - Remove redundant variables and reiterated definitions
  - Ground all uses of generics within a program, so a parser can just treat it as an extension of the identifier
  - Turn interface definitions into their constituents
  - Function differentials
  - Compute approximate worst-case computational time of a function, given specific inputs (value is N -> worst-case actual time is O(N))
  - Given a T -> T function, turn it into a T -> Boolean that returns whether the input would be turned into itself
- Port "code writing into Java" to Semlang

Design choices to reconsider:
- We might want a replacement for the "return" keyword
  - "use", "choose", "be", "select"
- Figure out what to do about recursive function calls
- Consider allowing trailing commas in e.g. argument lists
- Try failure: Include ways to distinguish sources of errors? (Union types for exception types?)
  - Stacktraces for debugging are considered outside the semantics of Semlang, and so are not included in the type system.
- Questionable or inconsistent native functions
  - Integer.fromNatural or Natural.toInteger?
- Slightly alternative semantics: A function ID is an expression representing a function binding for that function with
  empty bindings; this would simplify "named" vs. "expression" calls, but there would (still) be ambiguities between
  function IDs with no package and variables, and this would have to be sussed out in most transpilations.
- Use dot for follow and forward slash for ID separator? (Probably looks better with imports, worse without)


Probable dependencies of the type work:
- Function types/references depending on tuples
- Sequences depending on function references
- Interfaces depending on function references

As things are completed:
- Project Euler
- http://benchmarksgame.alioth.debian.org/

Less important, orthogonal to-dos:
- Clean up Gradle builds
- Consistent naming convention for .kt files
