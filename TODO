Major near-term projects:
- Threaded types, console-out support, and application functions
  - Ability to test functions involving threaded objects
  - Threaded structs
    - Destructuring statements
- Build system
  - Let's start by creating a repo where buildSrc depends on hand-built jars...
- Finish converting the validator to use fine-grained errors
- Sem2 and Try notation

Stuff that feels blocked or hasn't been implemented:
- Lemmas and proofs
  - Needs more consideration of both the predicates we should be operating on (how to reference parts of code?) and syntax
- Normal form
  - Not fully useful yet, other than for transformations; and we may be able to do that part more simply without the full
    normal form
- Recursion transformation
  - Needs something like the normal-form treatment to make function transformations easier, and might also need to be
    combined with other optimizations to be actually useful
  - Probably also needs test cases
  - Tail-call recursion might be easier to try implementing initially?
- Allow @Tests to have Lists as inputs or outputs
  - This needs design, and it should probably be a holistic design that includes structs as well
  - This is connected to the concept of allowing files to be reinterpreted as constant functions by the build system
- Write escape-rope code
  - More String library functions are needed: contains, replaceAll, join, StringBuilder
  - Interfaces don't work well yet when there's no data involved

- Clean up, organize code and sample Semlang code
  - Make things private when they can be
  - Turn NativeFunctions into library code written in semlang where possible
    - It would also be nice to have this in some .class form in a produced .jar, maybe?
  - Use a code coverage tool for the Kotlin tests
  - Apply Kotlin style guide, and maybe add linting?
  - Add tslint?
- Compiler test: Check for incorrect parameters on follow calls/instance calls
  - Also: args vs. fullyBoundArguments inline function issue seen in TS prior to this commit
- Can we change Sequence to be a struct rather than an interface again?
- Continue to shrink the set of native functions where possible
- Sem0: Link native types (structs, perhaps some library functions) into sem0 code
- Versioned publication of code corpuses
- Validation-time "requires" checking for extended literals
- Add ability for modules to re-export their imports (probably just specified in the config file for now)
- Have a list somewhere of the exposed methods that are intentionally "API"-ish in the Kotlin code
- Validator: Write more simple positive tests and negative tests
  - Try to squeeze out the obvious possibilities of wrongness
- Backwards-chaining interpreter; performance testing and output comparisons for forward, backward interpreters
  - Write some cases where this should skip actual work, check that it works as expected
- Finish up static validation TODOs
  - Validate struct member names
  - Validate function argument names
  - Make code style more consistent
- Support function bindings of instance constructors and adapter constructors
- List#firstIndex
- Additional primitive-ish types in the standard library (N-bit integers, floating-point numbers, rationals?)
- Other native-y types: Set, UniqueList, Map, Symbol, Snow?
- Try error tracking
- Mock tests in other environments
  - Transpiled Java
  - TypeScript interpreter
- There needs to be some way for interpreters/transpilers/compilers to have optional Semlang implementations of native
  thing A in terms of B, thing B in terms of A, etc.
- String library methods
- Add more escaped character options in string literals
- List literals: Don't require parameter type if non-empty
  - (But avoid this in the base language if it looks like we can't avoid subtypes in the future)
  - Support short-form embedded literals when parameter type is present
- Enum types
  - Might be a concept combinable with union types (like ADTs)?
  - ADTs and when expressions could subsume booleans and if/then
  - Is a singleton ADT really any different from a struct?
- DSL for "selecting" expressions from anywhere in a function
  - Point is to establish this before considering add'l characters in variable names
  - Use with Try.assert for an "Assertable" annotation? (e.g. for min or max, a list where size is >0)
- Real package/module declarations and use, including "import as" (note: "import as" could be a dialect/transformation)
- Typealias
- Code writing into Java
  - We should have some way to specify the exposed API, and check the inputs of these methods for e.g. Natural >= 0
  - Probably put all our code from one module into the same package
- Annotations and multiple function definitions
- Monads (e.g. start with support for console-out)
- Gradle manipulation of Semlang (i.e. beginnings of a build system)
- Real IDE-like editor environment (language server protocol)
- Interactive debugger of functions: drill down into results of subcalls
  - Mark results of specific functions as correct or incorrect for recording tests
  - Set up "normal" interpreter to record the results of specific functions; bridge into this after-the-fact analysis
    - (Record any non-determinism from monads while inside such a call)
- Offer alternative syntax with even easier parsing (e.g. commas prepended to lists, dots prepended to IDs)
  - Ideally this would also be designed to offer single-pass validation like WebAssembly
- Start to create dialects with simpler syntax, type inference, etc.
  - Also type inference for parameters when calling functions, for types that can be inferred (can these be separated somehow?)
  - Operators for dealing more easily with Try types (e.g. Foo? instead of Try<Foo>, ?: operator, ? for conditional calls)
- Semlang -> Semlang transformations, optimizations, etc.
  - Use only simple (non-nested) expressions
  - Remove redundant variables and reiterated definitions
  - Ground all uses of generics within a program, so a parser can just treat it as an extension of the identifier
  - Turn interface definitions into their constituents
  - Function differentials
  - Compute approximate worst-case computational time of a function, given specific inputs (value is N -> worst-case actual time is O(N))
  - Given a T -> T function, turn it into a T -> Boolean that returns whether the input would be turned into itself
- Port "code writing into Java" to Semlang

Figuring out packages and a module system:
  - I suspect that the JavaScript/npm module system is closer to what we want than the Java system (in its original
    form). Certainly we want the nice property of code exposing a fully controlled API and not its dependencies, as
    well as (related) including multiple
    - Related nice-to-have: Renaming types as they are imported.
  - It's worth researching Cargo here as well, as that system is recent and seems highly respected.
  - It would be nice to allow:
    - Specification of a target library within a source file (with the caveat that we want this in a centralized list
      in most places)
    - Specification of a cryptographic hash whenever we specify a dependency, to require that the version we pull in
      match the hash (for security's sake)
  - I think we want to be able to pull in imports from libraries
  - We'll have to figure out some way to deal with this when exporting to other languages, like Java. That could mean
    e.g. heavy use of shadowing, and/or the Java 9 build system.
  - Mandatory namespacing of e.g. "com.google.guava" or "google:guava" seems better than npm's free-for-all of first-tier
    names
  - Automatic semantic versioning would be awesome, but I don't know what that would look like yet.
    - I took a look at Elm and their version treats "function returns a different value" as a patch change, so I don't
      think that's sufficient (unless programmers are very, very well-behaved).
    - We may want to support multiple different notions of versioning, as well; for example, in some cases, clients will
      depend on the exact behavior of a function remaining fixed over time (eg. I/O formats) while in others, changes in
      behavior may be wanted immediately (e.g. an AI recommender system or time-zone information) even when used as a
      transitive dependency.
So a first pass would look like:
  - Groups of self-contained code are organized as modules, and have dependencies on other modules that by default are
    non-transitive (transitivity could be added later, in the form of re-declarations or otherwise).
  - Distribution/publication of modules online will happen at some point, but currently is TBD. Until then, we should
    probably allow internal repositories on a device (as some other repositories allow). In fact, it may be preferable
    to require use of such an internal repository as an intermediary in both directions (like a git repo). Caching on
    the way in, atomicity of publication (?) on the way out. Regardless of if we take that approach, this increases the
    similarity of formats between the systems.
    - So, we'll want a file format/directory structure for the published modules.
      - Probably at ~/.semlang/repo-1/ or the equivalent thereof, "-1" allowing for a future "-2" format, etc.
  - Code should probably be stored in whatever format is densest and/or most valuable for automated use. Of course, we
    will end up retaining comments (once they become annotations) and the like anyway...
  - We're already using namespacing for *.Adapter and it would make sense for closely related types (as seen in TS), so
    it shouldn't go away entirely, but "package" might be the wrong term now. It should probably be "namespace" and
    reserved for special cases within code, vs. including the org name, module name, etc. as seen in Java.
  - What does testing for this look like?
What a Gradle plugin for this would do:
  - Publish to the internal repository where approriate
  - Possibly allow "linking" of dependencies from peer projects as opposed to the repository
    - Do we want to specify all our dependencies in Gradle, or have a different mechanism to specify them? If the latter,
      is there a problem with Gradle here?
  - Once we know what our dependencies look like, run validation on the project's src/main/semlang and src/test/semlang,
    probably as an "assemble" task
  - As a "test" task, use the interpreter to run and check test annotations in the project
  - The plugin will probably depend on published jars containing the Kotlin parser, validator, and interpreter

Design choices to reconsider:
- Figure out what to do about recursive function calls
- Try failure: Include ways to distinguish sources of errors? (Union types for exception types?)
  - Stacktraces for debugging are considered outside the semantics of Semlang, and so are not included in the type system.
- Questionable or inconsistent native functions
- Slightly alternative semantics: A function ID is an expression representing a function binding for that function with
  empty bindings; this would simplify "named" vs. "expression" calls, but there would (still) be ambiguities between
  function IDs with no package and variables, and this would have to be sussed out in most transpilations.
- Use dot for follow and forward slash for ID separator? (Probably looks better with imports, worse without)
  - There might be a better version of this with the scope of namespaces more limited
- Probably rename the existing "Package" concept to "Namespace"

Errors I've made in writing things:
- (2) Used . in place of ->
- Forgot to export something
- (3) Typed "val" instead of "let"
- Forgot the "->value"
- Forgot Try.assume wrapping List.get
- Forgot type parameter of List.append
- Forgot to handle Try from a custom function
- Forgot to write "function" as part of a function definition

Distinctions between possible sem0/sem1/sem2:
- Things that should be applied before whole-program optimization techniques but not when looking at its source code
  - Language features that could be replaced with other things but would make code clunkier in the process:
    - Lambda expressions (replace with bindings of generated "normal" functions)
    - "Shortcut" literals
    - "Import" vs. module namespacing?
    - Default arguments? Named arguments?
    - Always merge all modules into a single module before optimizing/executing
    - Always have full references for entities from other modules (with no module references otherwise)
  - Language features that dialects might offer that standard semlang wouldn't
    - Operator overloading
    - Overloaded function names
    - Default/named arguments
    - Imperative style: Reassignable variables, while/for loops

Candidate monad semantics:
- Real monads can't be created; they can only be introduced by the caller of the initial function. However, there should
  also be some ability to "mock out" monads with deterministic code, even in production (consider PRNGs). There may also
  be a role for monad syntax in intermediate translations to other languages, e.g. turning string manipulation into a
  StringBuilder for Java.
- Basic syntax for sem0:
  - Monad types are separate and denoted by ! at the end
  - Passing a monad (say, StandardOut) into a function requires a name change for the monad using the >> operator:
    - Sample code:
function writeLine(myString: Unicode.String, out1 >> out3: StandardOut!) {
  StandardOut.write(out1 >> out2, myString)
  StandardOut.write(out2 >> out3, Unicode.String."\n")
}
    - Function is called as, e.g.: writeSomething(myString, out1 >> out2)
    - The required chain of variable names (adding and removing them from the scope in turn) is meant to remove any
      ambiguity about ordering in the case of, say, foo(bar(monad1 >> monad2), bar(monad2 >> monad3)). It might be
      acceptable for dialects to just use e.g. foo(bar(monad!), bar(monad!)) and have that transformed deterministically
      into the former approach down the chain; I just want to avoid the issue of implementations handling that order
      differently (or differing in whether to call things altogether).
    - However... I'm not sure how well this will work in the case of if/then/else expressions. Arguably that could be
      covered by allowing no-op "monad2 >> monad4" statements within the branch; that's just kind of awkward.
    - Monads wouldn't be allowed in normal structs due to the immutability issue, but there would be a "monad struct"
      entity type that is generally treated like a monad and allows for structuring of multiple monads.
    - Monads also shouldn't be allowed in normal function bindings. On the other hand, it would be nice to be able to
      use function bindings with monads, preferably with functions that take normal bindings as inputs. A straw man
      of how this might look:
let sortedList = bind foo|(monad1 >> monad2, myData, _, _) as boundFoo in {
  List.sort(unsortedList, boundFoo)
}
      One of the keys of how that works is that monad1 may take on a chain of values while it is in the block, but
      always ends up as monad2 at the end of it. Meanwhile, the scope inside the block would contain neither monad1 nor
      monad2 (but it would still have myData, by constrast). However... the problem is that the function binding itself
      now needs a single deterministic route through the program, which is not guaranteed in general for function
      bindings. Instead we'd need a "monadic function binding" type. And then we'd likely need a separate implementation
      of things like List.map, List.reduce, and Sequence.first that take function bindings as arguments.
    - I guess we shouldn't allow List<MyMonad!> and should instead have some MonadList!<MyMonad!> by analogy to the
      struct thing, as well.
    - At this point, things are complicated enough that I should take another look at how Haskell and other pure
      functional languages handle this. (Well... it looks like what I'm doing is the equivalent of "uniqueness types",
      which might be a more convenient/obvious name. Except that I wanted that UniqueList type...)
    - Could we use [] in lieu of >> notation? i.e., monad[1], monad[2], etc. to define the ordering over visits. Or
      something like monad#1 or monad^1 or monad@1 or monad!1 to make it otherwise clearer.
    - And given that these aren't actually monads, is there some possibly-original name to make it that much clearer to
      a casual observer how they work (while avoiding name collisions with existing concepts)?


As things are completed:
- Project Euler
- http://benchmarksgame.alioth.debian.org/

Less important, orthogonal to-dos:
- Clean up Gradle builds
- Consistent naming convention for .kt files
