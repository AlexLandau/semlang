- Clean up, organize code and sample Semlang code
  - Make things private when they can be
- Inform Gradle that the kotlin-parser tests depend on the src/test/semlang folder
- Have a list somewhere of the exposed methods that are intentionally "API"-ish
- Validator: Write more simple positive tests and negative tests
  - Try to squeeze out the obvious possibilities of wrongness
- Backwards-chaining interpreter; performance testing and output comparisons for forward, backward interpreters
  - Write some cases where this should skip actual work, check that it works as expected
- Finish up static validation TODOs
  - Validate struct member names
  - Validate function argument names
  - Make code style more consistent
- Function definitions as tests
- Function reference types
  - Also, don't rule out support for currying (e.g. as needed for a "compose" method)
  - Support references to struct constructors
- List type (index, map, reduce)
- Sequences and "first"
- Additional primitive types (N-bit integers, strings, characters, floating-point numbers, rationals?)
- Enum types
- Real package/module declarations and use, including "import as" (note: "import as" could be a dialect)
- Code writing into Java
- Annotations and multiple function definitions
- Interfaces/instances
- Monads (e.g. start with support for console-out)
- Real IDE-like editor environment
- Start to create dialects with simpler syntax, type inference, etc.
- Semlang -> Semlang optimizations, etc.
  - Ground all uses of generics within a program, so a parser can just treat it as an extension of the identifier
- Port "code writing into Java" to Semlang

Design choices to reconsider:
- Alternative keyword to "return" that better reflects how it's used in blocks in general?
  - "use", "choose", "be", "select"
- Figure out what to do about recursive function calls
- Integer.fromNatural or Natural.toInteger?
- Try failure: Include ways to distinguish sources of errors? (Union types for exception types?)
  - Stacktraces for debugging are considered outside the semantics of Semlang, and so are not included in the type system.

How will function types be represented? for (int, int) -> int:
- Function<(Integer, Integer), Integer>: Tuple inputs
  - Then how do we express in syntax "pass this tuple as the argument list"? Is that another native function?
  - Function<I: Tuple, O> as generic expression? Function<I extends Tuple, O>?
- Function<Integer, Integer, Integer>: Assume last is
  - Then can we genericize over functions of different arities? Should we?
- Function<2, Integer, Integer, Integer> or Function<2><Integer, Integer, Integer>
  - Seems potentially messy or silly...
  - Again, what do the generics look like? Function<N>? Function<N, T...>?
- Function2<Integer, Integer, Integer>
  - Does that give up composing over multiple functions?
  - compose() arguably only makes sense when the second is 1-arity anyway...
- (Integer, Integer) -> Integer
  - Abandon regularity of types; might make sense given the () "operator"

Probable dependencies of the type work:
- Function types/references depending on tuples
- Sequences depending on function references
- Interfaces depending on function references

As things are completed:
- Project Euler
- http://benchmarksgame.alioth.debian.org/
